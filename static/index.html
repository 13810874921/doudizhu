<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>斗地主</title>
    <link rel="stylesheet" href="/css/style.css">
</head>

<body>
    <div id="app">
        <!-- 大厅 -->
        <div class="full-screen house" v-if="where === 1">
            <div v-for="desk in desks" class="desk">
                <div v-for="position in desk.positions" class="position" :class="{has:position.state,position0:position.posId === 0,position1:position.posId === 1,position2:position.posId === 2}">
                    <span class="position-image" :class="{has:position.state}" @click="sitDown(desk.deskId,position)">
                    </span>
                    <span class="position-text" v-if="position.state">{{position.userName}}</span>
                </div>
                <div class="position-center">{{desk.deskId}}号桌</div>
            </div>
        </div>
        <!-- 房间 -->
        <div class="full-screen room" v-if="where === 2">
            <button class="btn-exit-room" @click="exitRoom">返回大厅</button>

            <div class="btn-group" v-if="roomState.state > 0 && roomState.ctxPos === 'self'">
                <span class="clock">{{roomState.timeout}}</span>
                <template v-if="roomState.state === 1">
                    <button class="btn btn-call" v-for="score in roomState.ctxScore" @click="callScore(score)">{{score}}分</button>
                    <button class="btn btn-call" @click="callScore(0)">不叫</button>
                </template>
                <template v-if="roomState.state === 2">
                    <button class="btn" @click="playCards">出牌</button>
                    <button class="btn" @click="passCards">不出</button>
                </template>

            </div>

            <button v-if="posState.self.state < 2" @click="prepare" class="btn-prepare">准备</button>

            <div class="card-groups" v-if="roomState.state">

                <!-- 自己的牌列表 -->
                <div class="card-group card-group-self" :style="{width:posState.self.cards.length * 20 + 70 + 'px'}"
                    v-if="posState.self.state > 1">
                    <div @dragStart="dragStart($event)" @click="selectCard(card)" v-for="(card,index) in posState.self.cards"
                        class="card" :class="'card-' + card.value + '-' + card.type" :style="{left:index * 20 + 'px',top:card.selected ? '-20px' : 0}">
                    </div>
                </div>
                <!-- 左家的牌列表 -->
                <div class="card-group card-group-left" :style="{width:posState.left.cards.length * 20 + 70 + 'px'}"
                    v-if="posState.left.state > 1">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.left.cards" class="card card-unknow"
                        :style="{left:index * 20 + 'px'}">
                    </div>
                    <div class="icon-group icon-group-left text-left" v-if="roomState.ctxPos == 'left'">
                        <span class="clock">{{roomState.timeout}}</span>
                    </div>
                    <div class="text-tips text-tips-left text-left">剩余：{{posState.left.cards.length}}张</div>

                </div>
                <!-- 右家的牌列表 -->
                <div class="card-group card-group-right" :style="{width:posState.right.cards.length * 20 + 70 + 'px'}"
                    v-if="posState.right.state > 1">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.right.cards" class="card card-unknow"
                        :style="{left:index * 20 + 'px'}">
                    </div>
                    <div class="icon-group icon-group-right text-right" v-if="roomState.ctxPos == 'right'">
                        <span class="clock">{{roomState.timeout}}</span>
                    </div>
                    <div class="text-tips text-tips-right text-right">剩余：{{posState.right.cards.length}}张</div>
                </div>
                <!-- 底牌列表 -->
                <div class="card-group card-group-top" :style="{width:posState.top.cards.length * 20 + 70 + 'px'}">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.top.cards" class="card" :style="{left:index * 20 + 'px'}"
                        :class="roomState.state ==2 ? 'card-' + card.value + '-' + card.type : ' card-unknow' ">
                    </div>
                </div>


            </div>

            <!-- 出牌区域 -->
            <div class="screen-center">
                <!-- 左家的出牌区域 -->
                <div class="card-ctx card-ctx-left" :style="{width:posState.left.ctxCards.length * 20 + 70 + 'px'}">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.left.ctxCards" class="card"
                        :class="'card-' + card.value + '-' + card.type" :style="{left:index * 20 + 'px'}">
                    </div>
                    <span class="score-tipe" v-if="roomState.state == 1 && posState.left.callScore > -1">{{posState.left.callScore
                        > 0 ? posState.left.callScore + '分' : '不叫' }}</span>

                </div>
                <!-- 自己的出牌区域 -->
                <div class="card-ctx card-ctx-self" :style="{width:posState.self.ctxCards.length * 20 + 70 + 'px'}">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.self.ctxCards" class="card"
                        :class="'card-' + card.value + '-' + card.type" :style="{left:index * 20 + 'px'}">
                    </div>
                    <span class="score-tipe" v-if="roomState.state == 1 && posState.self.callScore > -1">{{posState.self.callScore
                        > 0 ? posState.self.callScore + '分' : '不叫' }}</span>

                </div>
                <!-- 右家的出牌区域 -->
                <div class="card-ctx card-ctx-right" :style="{width:posState.right.ctxCards.length * 20 + 70 + 'px'}">
                    <div @dragStart="dragStart($event)" v-for="(card,index) in posState.right.ctxCards" class="card"
                        :class="'card-' + card.value + '-' + card.type" :style="{left:index * 20 + 'px'}">
                    </div>
                    <span class="score-tipe" v-if="roomState.state == 1 && posState.right.callScore > -1">{{posState.right.callScore
                        > 0 ? posState.right.callScore + '分' : '不叫' }}</span>

                </div>
            </div>
            <!-- 玩家头像 -->
            <div class="players">
                <div class="screen-center">
                    <div class="player-wrapper player-left" v-if="posState.left.state">
                        <div class="player-photo"></div>
                        <div class="player-name text-center">{{posState.left.name}}</div>
                        <div class="text-center player-status" v-if="posState.left.state === 2 && roomState.state === 0">准备</div>
                    </div>
                    <div class="player-wrapper player-right" v-if="posState.right.state">
                        <div class="player-photo"></div>
                        <div class="player-name text-center">{{posState.right.name}}</div>
                        <div class="text-center player-status" v-if="posState.right.state === 2 && roomState.state === 0">准备</div>
                    </div>

                </div>
                <div class="player-wrapper player-self" v-if="roomState.state === 0">
                    <div class="player-photo"></div>
                    <div class="player-name text-center">{{posState.self.name}}</div>
                    <div class="text-center player-status" v-if="posState.self.state === 2 && roomState.state === 0">准备</div>
                </div>
            </div>

        </div>

    </div>
    <script src="/js/vue.min.js"></script>
    <script src="socket.io/socket.io.js"></script>
    <script src="/js/jquery.min.js"></script>
    <script src="js/layer/layer.js"></script>
    <script>


        //数组排序
        function arraySort(array, asc) {
            return array.sort(function (a, b) {
                return asc === 'asc' ? a - b : b - a;
            })
        }

        //获取 0-num范围的随机整数
        function getRandomNumForRange(num) {
            return Math.round(Math.random() * num);
        }

        //计算数组中每个成员出现的次数，返回一个去重的次数数组
        function getCountArrayForGroupByCard(array, asc) {
            var ret = getGroupByCard(array);
            var r = [];
            for (var i in ret) {
                (r.indexOf(ret[i]) === -1) && r.push(ret[i]);
            }
            r = arraySort(r, asc);
            return r;
        }

        //统计数组中每个成员出现的次数
        function getGroupByCard(array) {
            var ret = {};
            array.forEach(function (item) {
                if (ret[item] === undefined) {
                    ret[item] = 0;
                }
                ret[item]++;
            });
            return ret;
        }

        //数组去重
        function arrayClearRepeat(array) {
            var ret = [];
            array.forEach(function (item) {
                if (ret.indexOf(item) === -1) {
                    ret.push(item);
                }
            });
            return ret;
        }

        //从一个数组中过滤掉 >=n 的成员
        function removeItemOverOf(array, n) {
            return array.filter(function (item) {
                return item < n;
            });
        }


        ///数组的最大成员是否 < n;
        function maxItemLessThan(array, n) {
            return Math.max.apply(Math, array) < n;
        }

        ///数组的最大成员是否 >= n;
        function maxItemMoreThan(array, n) {
            return Math.max.apply(Math, array) >= n;
        }

        //获取数组中最小的成员;
        function getMinItem(array) {
            if (!array.length) {
                return undefined;
            }
            return Math.min.apply(Math, array);
        }
        //获取数组中最大的成员
        function getMaxItem(array) {
            if (!array.length) {
                return undefined;
            }
            return Math.max.apply(Math, array);
        }

        //筛选数组中累计出现过至少n次的成员
        function getCardByCountOverOf(array, n) {
            var ret = getGroupByCard(array);
            var r = [];
            for (var i in ret) {
                if (ret[i] >= n) {
                    r.push(parseInt(i));
                }
            }
            return r;
        }

        //筛选数组中出现过n次的成员
        function getCardByCount(array, n) {
            var ret = getGroupByCard(array);
            var r = [];
            for (var i in ret) {
                if (ret[i] === n) {
                    r.push(parseInt(i));
                }
            }
            return r;
        }

        //筛选数组中出现n次的成员与其它出现n次的成员，
        //若能组成等差数组，则返回这些成员的list（最长的那个等差数列,若长度一致，取最大的那一列）
        function getSequence(array, n) {
            var r = arraySort(getCardByCount(array, n), 'asc');
            var rets = [];
            var ret = [];
            var maxIndex = r.length - 1;
            for (var i = 0; i < maxIndex; i++) {
                var prev = r[i];
                var curr = r[i + 1];
                if (curr - prev === 1 && curr < 15) {
                    if (ret.indexOf(prev) === -1) {
                        ret.push(prev);
                    }
                    if (ret.indexOf(curr) === -1) {
                        ret.push(curr);
                    }
                    if (i === maxIndex - 1) {
                        rets.push(ret);
                    }
                } else {
                    rets.push(ret);
                    ret = [];
                }
            }
            rets = rets.sort(function (a, b) {
                return a.length - b.length;
            });
            return rets.pop() || [];

        }


        //检查数组是否为等差数组 （差值 1）
        // {Array} param
        // {boolean} return
        function checkSequence(array) {
            array = arraySort(array, 'asc');
            for (var i = 0, len = array.length - 1; i < len; i++) {
                var prev = array[i];
                var current = array[i + 1];
                if (current - prev !== 1) {
                    return false;
                }
            }
            return true;
        }
        //顺子 N 张
        function ABCDE_N(cards, count) {
            var cards = arraySort(cards, 'asc');

            if (maxItemMoreThan(cards, 15)) {
                return false;
            }
            var ret = checkSequence(cards);
            if (count === undefined) {
                return ret;
            } else {
                return ret && cards.length === count;
            }
        }
        //连对N对
        function AABBCC_N(cards, count) {
            var ret = getGroupByCard(cards);
            var retKeys = arraySort(Object.keys(ret), 'asc');
            if (maxItemMoreThan(retKeys, 15)) {
                return false;
            }
            var flag = checkSequence(retKeys);
            if (!flag) {
                return false;
            }
            var r = getCountArrayForGroupByCard(cards, 'asc');
            return r.length === 1 && r[0] === 2 && cards.length === count && count % 2 === 0;
        }
        //飞机不带翅膀N飞
        function AAABBB_N(cards, count) {
            var countList = getCountArrayForGroupByCard(cards, 'asc');
            var mCards = getGroupByCard(cards);
            mCards = arraySort(Object.keys(mCards), 'asc');
            if (maxItemMoreThan(mCards, 15)) {
                return false;
            }
            var ret = checkSequence(mCards);
            return ret && countList.length === 1 && countList[0] === 3 && cards.length === count;
        }

        //飞机带单N飞
        function AAABBB_N_CD_N(cards, count) {
            var ret = arraySort(getCardByCountOverOf(cards, 3), 'asc');
            ret = removeItemOverOf(ret, 15);
            if (ret.length < count / 4) {
                return {
                    status: false
                };
            }
            var r = getSequence(ret, 1);
            if (r.length < count / 4) {
                return { status: false };
            }
            var key = getMinItem(r);
            var status = cards.length === count;
            return {
                key: key,
                status: status
            }
        }

        //双飞以上带对
        function AAABB_N(cards, count) {
            cards = cards.slice(0);
            if (count % 5 !== 0) {
                return false;
            }
            var ret = getSequence(cards, 3);
            if (ret.length !== count / 5) {
                return false;
            }
            var r = [];
            cards.forEach(function (item) {
                (ret.indexOf(item) === -1) && r.push(item);
            });
            r = arraySort(r, 'asc');
            if (r.length !== (count / 5) * 2) {
                return false;
            }
            r = getCountArrayForGroupByCard(r, 'asc');
            for (var i = 0, len = r.length; i < len; i++) {
                if (r[i] !== 4 && r[i] !== 2) {
                    return false;
                }
            }
            return true;
        }

        var TYPES = {

            //[1张的时候] 
            // 单张
            A: function (cards) {
                return {
                    len: 1,
                    key: cards[0],
                    status: cards.length === 1
                }
            },





            //[2张的时候] 
            //对子
            AA: function (cards) {
                var status = cards.length === 2 && cards[0] === cards[1];
                return {
                    len: 2,
                    key: cards[0],
                    status: status
                }
            },
            //王炸
            KING: function (cards) {
                var ret = arraySort(cards, 'asc');
                var status = ret.length === 2 && ret[0] + ret[1] === 33;
                return {
                    len: 2,
                    key: 16,
                    status: status
                }
            },




            //[3张的时候] 
            //三不带
            AAA: function (cards) {
                var status = cards.length === 3 && cards[0] === cards[1] && cards[1] === cards[2];
                return {
                    len: 3,
                    key: cards[0],
                    status: status
                }
            },





            //[4张的时候] 
            //炸弹（四张）
            AAAA: function (cards) {
                var ret = arrayClearRepeat(cards);
                var status = ret.length === 1 && cards.length === 4;
                return {
                    len: 4,
                    key: cards[0],
                    status: status
                }
            },
            //三带一
            AAAB: function (cards) {
                var r = getCountArrayForGroupByCard(cards, 'desc');
                var ret = getCardByCount(cards, 3);
                var status = r.length === 2 && r[0] === 3 && r[1] === 1 && cards.length === 4;
                return {
                    len: 4,
                    key: ret[0],
                    status: status
                }
            },





            //[5张的时候] 
            //三带二（三带一对）
            AAABB: function (cards) {
                var r = getCountArrayForGroupByCard(cards, 'desc');
                var ret = getCardByCount(cards, 3);
                var status = r.length === 2 && r[0] === 3 && r[1] === 2 && cards.length === 5;
                return {
                    len: 5,
                    key: ret[0],
                    status: status
                }
            }
            ,
            //顺子5张
            ABCDE_5: function (cards) {
                var status = ABCDE_N(cards, 5);
                return {
                    len: 5,
                    key: getMinItem(cards),
                    status: status
                }
            }
            ,




            //[6张的时候] 
            //顺子6张
            ABCDE_6: function (cards) {
                var status = ABCDE_N(cards, 6);
                return {
                    len: 6,
                    key: getMinItem(cards),
                    status: status
                }
            }
            ,
            //连对
            AABBCC_6: function (cards) {
                var status = AABBCC_N(cards, 6);
                return {
                    len: 6,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //四带二
            AAAABC: function (cards) {
                var r = getCountArrayForGroupByCard(cards, 'desc');
                var status = [2, 3].indexOf(r.length) > -1 && r[0] === 4 && cards.length === 6;
                return {
                    len: 6,
                    key: getCardByCount(cards, 4)[0],
                    status: status
                }
            },
            //双飞不带
            AAABBB: function (cards) {
                var status = AAABBB_N(cards, 6);
                return {
                    len: 6,
                    key: getMinItem(cards),
                    status: status
                }
            },



            //[7张的时候] 
            //顺子7张
            ABCDE_7: function (cards) {
                var status = ABCDE_N(cards, 7);
                return {
                    len: 7,
                    key: getMinItem(cards),
                    status: status
                }
            },





            //[8张的时候]           
            //顺子8张
            ABCDE_8: function (cards) {
                var status = ABCDE_N(cards, 8);
                return {
                    len: 8,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //双飞带二张(AAABBBAB也应满足 [连续的两炸])
            AAABBB_CD: function (cards) {
                var data = AAABBB_N_CD_N(cards, 8);
                return {
                    len: 8,
                    key: data.key,
                    status: data.status
                }
            },
            //连对 8张
            AABBCC_8: function (cards) {
                var status = AABBCC_N(cards, 8);
                return {
                    len: 8,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //4带2对(AAAABBBB也算)
            AAAABBCC: function (cards) {
                var status = {
                    len: 8,
                    key: undefined,
                    status: false
                };
                if (cards.length !== 8) {
                    return status;
                }
                cards = cards.slice(0);
                var ret = getCardByCountOverOf(cards, 4);
                if (ret.length === 2) {
                    status.key = getMaxItem(ret);
                    status.status = true;
                    return status;
                }
                else if (ret.length < 1) {
                    return status;
                }
                else if (ret.length === 1) {
                    var r = [];
                    var exceptCard = ret[0];
                    cards.forEach(function (card) {
                        if (card !== exceptCard) {
                            r.push(card);
                        }
                    });
                    r = arraySort(r, 'asc');
                    status.key = exceptCard;
                    status.status = r[0] === r[1] && r[2] === r[3];
                    return status;
                }
                else {
                    return status;
                }
            },



            //[9张的时候]
            //顺子9张
            ABCDE_9: function (cards) {
                var status = ABCDE_N(cards, 9);
                return {
                    len: 9,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //三飞不带
            AAABBB_9: function (cards) {
                var status = AAABBB_N(cards, 9);
                return {
                    len: 9,
                    key: getMinItem(cards),
                    status: status
                }
            },


            //[10张的时候]
            //顺子10张
            ABCDE_10: function (cards) {
                var status = ABCDE_N(cards, 10);
                return {
                    len: 10,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //连对10张
            AABBCC_10: function (cards) {
                var status = AABBCC_N(cards, 10);
                return {
                    len: 10,
                    key: getMinItem(cards),
                    status: status
                }
            }
            ,
            //双飞带两对   
            AAABBBCCDD: function (cards) {
                var status = AAABB_N(cards, 10);
                var ret = getCardByCount(cards, 3);
                return {
                    len: 10,
                    key: getMinItem(ret),
                    status: status
                }
            },



            //[11张的时候]
            //顺子11张
            ABCDE_11: function (cards) {
                var status = ABCDE_N(cards, 11);
                return {
                    len: 11,
                    key: getMinItem(cards),
                    status: status
                }
            },


            //[12张的时候]
            //顺子12张
            ABCDE_12: function (cards) {
                var status = ABCDE_N(cards, 12);
                return {
                    len: 12,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //连对 12张
            AABBCC_12: function (cards) {
                var status = AABBCC_N(cards, 12);
                return {
                    len: 12,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //四飞不带
            AAABBB_12: function (cards) {
                var status = AAABBB_N(cards, 12);
                return {
                    len: 12,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //三飞带三张
            AAABBB_CD_12: function (cards) {
                var data = AAABBB_N_CD_N(cards, 12);
                return {
                    len: 12,
                    key: data.key,
                    status: data.status
                }
            },

            //[13张的时候]
            //无

            //[14张的时候]
            //连对14张
            AABBCC_14: function (cards) {
                var status = AABBCC_N(cards, 14);
                return {
                    len: 14,
                    key: getMinItem(cards),
                    status: status
                }
            },


            //[15张的时候]
            //三飞带三对
            AAABB_15: function (cards) {
                var status = AAABB_N(cards, 15);
                var ret = getCardByCount(cards, 3);
                return {
                    len: 15,
                    key: getMinItem(ret),
                    status: status
                }
            },
            //5飞不带
            AAABBB_15: function (cards) {
                var status = AAABBB_N(cards, 15);
                return {
                    len: 15,
                    key: getMinItem(cards),
                    status: status
                }
            },


            //[16张的时候]
            //连对16张
            AABBCC_16: function (cards) {
                var status = AABBCC_N(cards, 16);
                return {
                    len: 16,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //4飞带4张
            AAABBB_CD_16: function (cards) {
                var data = AAABBB_N_CD_N(cards, 16);
                return Object.assign({ len: 16 }, data);
            },

            //[17张的时候]
            //无

            //[18张的时候]
            //连对 18张
            AABBCC_18: function (cards) {
                var status = AABBCC_N(cards, 18);
                return {
                    len: 18,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //6飞不带
            AAABBB_18: function (cards) {
                var status = AAABBB_N(cards, 18);
                return {
                    len: 18,
                    key: getMinItem(cards),
                    status: status
                }
            },

            //[19张的时候]
            //无

            //[20张的情况]
            //连对20张
            AABBCC_20: function (cards) {
                var status = AABBCC_N(cards, 20);
                return {
                    len: 20,
                    key: getMinItem(cards),
                    status: status
                }
            },
            //5飞带5张
            AAABBB_CD_20: function (cards) {
                var data = AAABBB_N_CD_N(cards, 20);
                return Object.assign({ len: 20 }, data);
            },
            //四飞带四对(5 x 4)
            AAABB_20: function (cards) {
                var status = AAABB_N(cards, 20);
                var ret = getCardByCount(cards, 3);
                return {
                    len: 20,
                    key: getMinItem(ret),
                    status: status
                }
            }

        }



        var cardValidator = {
            1: [['A', TYPES.A]],
            2: [['AA', TYPES.AA], ['KING', TYPES.KING]],
            3: [['AAA', TYPES.AAA]],
            4: [['AAAA', TYPES.AAAA], ['AAAB', TYPES.AAAB]],
            5: [['AAABB', TYPES.AAABB], ['ABCDE', TYPES.ABCDE_5]],
            6: [
                ['ABCDE', TYPES.ABCDE_6],
                ['AABBCC', TYPES.AABBCC_6],
                ['AAAABC', TYPES.AAAABC],
                ['AAABBB', TYPES.AAABBB]
            ],
            7: [
                ['ABCDE', TYPES.ABCDE_7],
            ],
            8: [
                ['ABCDE', TYPES.ABCDE_8],
                ['AAAB', TYPES.AAABBB_CD],
                ['AABBCC', TYPES.AABBCC_8],
                ['AAAABBCC', TYPES.AAAABBCC]
            ],
            9: [
                ['ABCDE', TYPES.ABCDE_9],
                ['AAABBB', TYPES.AAABBB_9]
            ],
            10: [
                ['ABCDE', TYPES.ABCDE_10],
                ['AABBCC', TYPES.AABBCC_10],
                ['AAABB', TYPES.AAABBBCCDD]
            ],
            11: [
                ['ABCDE', TYPES.ABCDE_11]
            ],
            12: [
                ['ABCDE', TYPES.ABCDE_12],
                ['AABBCC', TYPES.AABBCC_12],
                ['AAABBB', TYPES.AAABBB_12],
                ['AAAB', TYPES.AAABBB_CD_12]
            ],
            13: [],
            14: [['AABBCC', TYPES.AABBCC_14]],
            15: [
                ['AAABB', TYPES.AAABB_15],
                ['AAABBB', TYPES.AAABBB_15]
            ],
            16: [
                ['AABBCC', TYPES.AABBCC_16],
                ['AAAB', TYPES.AAABBB_CD_16]
            ],
            17: [],
            18: [
                ['AABBCC', TYPES.AABBCC_18],
                ['AAABBB', TYPES.AAABBB_18]
            ],
            19: [],
            20: [
                ['AABBCC', TYPES.AABBCC_20],
                ['AAABBB', TYPES.AAABBB_CD_20],
                ['AAABB', TYPES.AAABB_20],
            ]
        }


        function getCards(position) {
            for (var i = 0, len = contextCards.length; i < len; i++) {
                var item = contextCards[i];
                if (item.id === position) {
                    return item.cards;
                }
            }
            return null;
        }
        function getCardIndexByPosition(card, position) {
            var cards = getCards(position);
            for (var i = 0, len = cards.length; i < len; i++) {
                var curr = cards[i];
                if (curr.value === card.value && curr.type === card.type) {
                    return i;
                }
            }
            return -1;
        }

        function getCardIndexByCards(card, cards) {
            for (var i = 0, len = cards.length; i < len; i++) {
                var curr = cards[i];
                if (curr.value === card.value && curr.type === card.type) {
                    return i;
                }
            }
            return -1;
        }

        function removeCards(cards, position) {
            var sourceCards = getCards(position);
            for (var i = 0; i < cards.length; i++) {
                var card = cards[i];
                var index = getCardIndexByCards(card, sourceCards);
                if (index !== -1) {
                    sourceCards.splice(index, 1);
                }
            }
        }
        //检查牌是否存在，防客户端作弊
        function checkExist(cards, position) {
            for (var i = 0; i < cards.length; i++) {
                var card = cards[i];
                var index = getCardIndexByPosition(card, position);
                if (index === -1) {
                    return false;
                }
            }
            return true;
        }


        //验证牌型
        function validate(cards) {
            var len = cards.length;
            var int_cards = cards.map(function (card) {
                return card.value;
            });
            var validators = cardValidator[len];
            if (len < 1 || len > 20 || !validators.length) {
                return {
                    status: false,
                    len: len,
                    types: []
                };
            }
            var ret = [];
            validators.forEach(function (array) {
                var type = array[0];
                var validator = array[1];
                var result = validator(int_cards);
                if (result.status) {
                    result.type = type;
                    ret.push(result);
                }
            });
            if (ret.length) {
                return {
                    status: true,
                    len: len,
                    types: ret
                }
            } else {
                return {
                    status: false,
                    len: len,
                    types: []
                };
            }

        }


        function createClient(url) {
            var socket = io.connect('ws://' + url);
            return socket;
        }

        var vm = new Vue({
            el: "#app",
            data: function () {
                return {
                    where: 1,//0登录界面 1大厅 2房间,
                    posId: '',//座位号
                    deskId: '',//桌号
                    desks: [],
                    client: '',

                    cards: [],

                    //房间状态
                    roomState: {
                        state: 0,//0准备状态 1叫分状态 2打牌状态
                        ctxPos: '', //当前该哪个座位谁出牌或叫分 left right or self
                        ctxCard: { //上家玩家的牌型
                            len: 0,
                            key: '',
                            type: '',
                            ctxPos: ''
                        },
                        ctxScore: [],
                        timeout: 15,

                    },
                    //座位状态
                    posState: {
                        top: {
                            cards: []
                        },
                        left: {
                            state: 0,//0没人，1未准备 2准备
                            cards: [],
                            ctxCards: [],
                            callScore: -1,
                            name: '游客'
                        },
                        right: {
                            state: 0,//0没人，1未准备 2准备
                            cards: [],
                            ctxCards: [],
                            callScore: -1,
                            name: '游客'
                        },
                        self: {
                            state: 0,//0没人，1未准备 2准备
                            cards: [],
                            ctxCards: [],
                            callScore: -1,
                            name: '游客'
                        }
                    }
                }
            },
            mounted: function () {
                var self = this;
                this.$nextTick(function () {
                    document.oncontextmenu = function (e) {
                        e.preventDefault();
                        self.playCards();
                    };

                    this.client = createClient(location.host);

                    this.client.on('MESSAGE', function (data) {
                        layer.msg(data.msg);
                    }.bind(this));

                    this.client.on('LOGIN_SUCCESS', function (data) {
                        this.desks = data;
                    }.bind(this));

                    this.client.on('SITDOWN_SUCCESS', function (data) {
                        this.where = 2;
                        this.posId = data.posId;
                        this.deskId = data.deskId;
                        data.posInfos.forEach(function (pos) {
                            this.updatePosStatus(pos.posId, pos.state, pos.name);
                        }.bind(this))

                        layer.closeAll();
                    }.bind(this));

                    this.client.on('SITDOWN_ERROR', function (data) {
                        layer.closeAll();
                        layer.msg(data.msg);
                    }.bind(this));


                    this.client.on('UNSITDOWN_SUCCESS', function (data) {
                        this.resetRoomStatus();
                        this.desks = data;
                        layer.closeAll();
                    }.bind(this));

                    this.client.on('REFRESH_LIST', function (data) {
                        this.desks = data;
                    }.bind(this));

                    this.client.on('STATUS_CHANGE', function (data) {
                        this.updateHouseStatus(data.deskId, data.posId, data.state);
                    }.bind(this));

                    this.client.on('POS_STATUS_CHANGE', function (data) {
                        this.updatePosStatus(data.posId, data.state);
                    }.bind(this));

                    this.client.on('POS_STATUS_RESET', function (data) {
                        data.pos.forEach(function (pos) {
                            this.updatePosStatus(pos.posId, data.state);
                        }.bind(this));
                    }.bind(this));

                    this.client.on('ROOM_STATUS_CHANGE', function (data) {
                        this.roomState.state = data.state;
                    }.bind(this));

                    this.client.on('FORCE_EXIT_EV', function (data) {
                        layer.msg(data.msg);

                        this.roomState.state = 0;
                        this.posState.left.callScore = -1;
                        this.posState.right.callScore = -1;
                        this.posState.self.callScore = -1;

                    }.bind(this));

                    this.client.on('PREPARE_SUCCESS', function (data) {
                        this.posState.self.state = 2;
                        layer.closeAll();
                    }.bind(this));

                    //游戏开始
                    this.client.on('GAME_START', function (data) {
                        this.roomState.state = 1;
                        this.initCards(data.cards);
                    }.bind(this));


                    //叫分事件
                    this.client.on('CTX_USER_CHANGE', function (data) {
                        this.updateCtxInfo(data);
                    }.bind(this));

                    //显示底牌事件
                    this.client.on('SHOW_TOP_CARD', function (data) {
                        this.roomState.state = 2;
                        var direct = this.getDirectionByPosId(data.dizhuPosId);
                        if (direct == 'self') {
                            data.topCards.forEach(function (card) {
                                card.selected = true;
                            })
                            this.posState[direct].cards = this.posState[direct].cards.concat(data.topCards).sort(function (a, b) {
                                return a.value - b.value;
                            });
                        } else {
                            this.posState[direct].cards = this.posState[direct].cards.concat(data.topCards);
                        }
                        this.posState.top.cards = data.topCards;
                        this.roomState.ctxPos = direct;
                        this.roomState.timeout = data.timeout;
                        this.startTimer();
                    }.bind(this));



                    this.client.on('CTX_PLAY_CHANGE', function (data) {
                        var direct = this.getDirectionByPosId(data.ctxData.posId);
                        this.posState[direct].ctxCards = data.ctxData.cards;
                        if (data.ctxData.len) {
                            this.roomState.ctxCard.len = data.ctxData.len;
                            this.roomState.ctxCard.key = data.ctxData.key;
                            this.roomState.ctxCard.type = data.ctxData.type;
                            this.roomState.ctxCard.ctxPos = direct;
                        }
                        this.roomState.ctxPos = this.getDirectionByPosId(data.posId);
                        this.roomState.timeout = data.timeout;
                        this.startTimer();


                    }.bind(this));

                }.bind(this));
            },
            methods: {
                getDesk: function (deskId) {
                    for (var i = 0, len = this.desks.length; i < len; i++) {
                        var desk = this.desks[i];
                        if (desk.deskId === deskId) {
                            return desk;
                        }
                    }
                    return null;
                },
                getPos: function (deskId, posId) {
                    var desk = this.getDesk(deskId);
                    if (desk) {
                        for (var i = 0, len = desk.positions.length; i < len; i++) {
                            var pos = desk.positions[i];
                            if (pos.posId === posId) {
                                return pos;
                            }
                        }
                    }
                    return null;
                },
                callScore: function (score) {
                    this.posState.self.callScore = score;
                    this.roomState.ctxPos = '';
                    this.client.emit('CALL_SCORE', { score: score });
                },
                updateCtxInfo: function (data) {
                    var ctx = data;
                    var direction = this.getDirectionByPosId(ctx.ctxPos);
                    ctx.ctxPos = direction;
                    this.roomState.ctxPos = ctx.ctxPos;
                    this.roomState.ctxScore = ctx.ctxScore;
                    this.roomState.timeout = ctx.timeout;
                    if (ctx.calledScores) {
                        for (var key in ctx.calledScores) {
                            if (ctx.calledScores.hasOwnProperty(key)) {
                                var posId = Number(key);
                                var direct = this.getDirectionByPosId(posId);
                                this.posState[direct].callScore = ctx.calledScores[key];
                            }
                        }
                    }
                    this.startTimer(function () {
                        if (this.roomState.ctxPos == 'self') {
                            this.callScore(0);
                        }
                    });
                },
                startTimer: function () {
                    var timer = null;
                    return function (fn) {
                        var self = this;
                        if (timer) {
                            clearInterval(timer);
                        }
                        timer = setInterval(function () {
                            self.roomState.timeout--;
                            if (self.roomState.timeout <= 0) {
                                clearInterval(timer);
                                timer = null;
                                self.roomState.timeout = 0;
                                fn && fn.call(self);
                            }
                        }, 1000)

                    }
                }(),
                updateHouseStatus: function (deskId, posId, state) {
                    var pos = this.getPos(deskId, posId);
                    if (pos) {
                        pos.state = state;
                    }
                },
                //通过posId获取是哪个方向的坐位
                getDirectionByPosId: function (posId) {
                    var mapping = {
                        0: {
                            0: 'self',
                            1: 'right',
                            2: 'left',
                            3: 'top',
                        },
                        1: {
                            1: 'self',
                            2: 'right',
                            0: 'left',
                            3: 'top',
                        },
                        2: {
                            2: 'self',
                            0: 'right',
                            1: 'left',
                            3: 'top',
                        }

                    }
                    return mapping[this.posId][posId];
                },
                updatePosStatus: function (posId, state, name) {
                    var redirection = this.getDirectionByPosId(posId);
                    this.posState[redirection].state = state;
                    this.posState[redirection].name = name || '';

                },
                sitDown: function (deskId, pos) {
                    if (pos.state === 0) {
                        layer.load({ type: 3 });
                        this.client.emit('SITDOWN', { deskId: deskId, posId: pos.posId });

                    }
                },
                exitRoom: function () {
                    this.client.emit('UNSITDOWN');
                    layer.load({ type: 3 });
                },
                resetRoomStatus: function () {
                    this.where = 1;
                    this.posId = '';
                    this.deskId = '';
                    this.posState.self.state = 0;
                    this.roomState.state = 0;
                    this.posState.left.callScore = -1;
                    this.posState.right.callScore = -1;
                    this.posState.self.callScore = -1;
                },
                getSelectdCards: function () {
                    return this.posState.self.cards.filter(function (card) {
                        return card.selected;
                    });
                },
                getCardIndex: function (card) {
                    var cards = this.posState.self.cards;
                    for (var i = 0, len = cards.length; i < len; i++) {
                        var item = cards[i];
                        if (card.value === item.value && card.type === item.type) {
                            return i;
                        }
                    }
                    return -1;
                },
                removeCards: function (cards) {
                    cards.forEach(function (card) {
                        var index = this.getCardIndex(card);
                        if (index !== -1) {
                            this.posState.self.cards.splice(index, 1);
                        }
                    }.bind(this));
                },


                playCards: function (cards) {
                    if (this.roomState.ctxPos !== 'self') {
                        return layer.msg('未到出牌时间');
                    }

                    var cards = this.getSelectdCards();
                    var ret = validate(cards);
                    if (!ret.status) {
                        return layer.msg('你的牌不符合规则');
                    }

                    //上一次有效出牌的人若不是自己，则需要出更大的牌
                    if (this.roomState.ctxCard.ctxPos !== 'self') {
                        if (this.roomState.ctxCard.type === 'KING') {
                            return layer.msg('你的牌不符合规则');
                        }
                        else if (this.roomState.ctxCard.type === 'AAAA') {
                            if (ret.type !== 'KING') {
                                if (ret.type !== 'AAAA') {
                                    return layer.msg('你的牌不符合规则');
                                }
                                if (ret.type === 'AAAA' && this.roomState.ctxCard.key > ret.key) {
                                    return layer.msg('你的牌不符合规则');
                                }
                            }

                        }else{
                            if(ret.type !== 'KING' && ret.type !== 'AAAA'){
                                if(ret.len !== this.roomState.ctxCard.len 
                                ||ret.key < this.roomState.ctxCard.key
                                ||ret.type !== this.roomState.ctxCard.type){
                                    return layer.msg('你的牌不符合规则');
                                }
                            }
                        }


                    }
                    this.posState.self.ctxCards = cards;
                    this.removeCards(cards);
                },
                //不出
                passCards: function () {

                },
                prepare: function () {
                    layer.load({ type: 3 });
                    this.client.emit('PREPARE');
                },
                dragStart: function (e) {
                    e.preventDefault();
                },
                selectCard: function (card) {
                    card.selected = !card.selected;
                },
                initCards: function (cards) {
                    cards.forEach(function (cardGroup, index) {
                        cardGroup.cards.forEach(function (card) {
                            card.selected = false;
                        });
                        var posId = cardGroup.id;
                        var redirection = this.getDirectionByPosId(posId);
                        this.posState[redirection].cards = cardGroup.cards;
                    }.bind(this));
                }
            }
        })

    </script>
</body>

</html>